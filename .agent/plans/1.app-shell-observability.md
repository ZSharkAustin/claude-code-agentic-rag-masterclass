# Module 1: App Shell + Observability

⚠️ **Medium** - Multiple integration points (Supabase Auth, OpenAI Responses API, LangSmith, SSE streaming), but each is well-documented. Achievable in one focused session.

---

## Section 1: Project Scaffolding

### Task 1.1: Initialize Vite + React + TypeScript frontend

Create the frontend project with Vite, React, TypeScript, Tailwind CSS, and shadcn/ui.

**Files:** `frontend/` (scaffolded via Vite + shadcn init)

**Commands:**
```bash
npm create vite@latest frontend -- --template react-ts
cd frontend && npm install
npm install -D @tailwindcss/vite
npx shadcn@latest init
npx shadcn@latest add button input card avatar scroll-area separator sheet dialog dropdown-menu label textarea
```

**Validation:** `npm run dev` starts Vite at `http://localhost:5173` with a working page.

---

### Task 1.2: Initialize FastAPI backend with venv

**Files to create:**
- `backend/requirements.txt`
- `backend/app/__init__.py`
- `backend/app/main.py` — FastAPI app with CORS
- `backend/app/config.py` — Pydantic Settings for env vars

**`requirements.txt`:**
```
fastapi[standard]>=0.115.0
uvicorn[standard]>=0.32.0
openai>=1.60.0
supabase>=2.11.0
langsmith>=0.2.0
pydantic>=2.10.0
pydantic-settings>=2.7.0
python-dotenv>=1.0.0
sse-starlette>=2.2.0
httpx>=0.28.0
```

**`config.py` — env vars:**
- `supabase_url`, `supabase_anon_key`
- `openai_api_key`, `openai_model` (default `gpt-4o-mini`)
- `langsmith_api_key`, `langsmith_project` (default `rag-masterclass`), `langsmith_tracing` (default `true`)
- `frontend_url` (default `http://localhost:5173`)

**`main.py`:** FastAPI app + CORSMiddleware + `GET /health` endpoint.

**Commands:**
```bash
cd backend && python3 -m venv venv && source venv/bin/activate && pip install -r requirements.txt
```

**Validation:** `uvicorn app.main:app --reload` → `curl http://localhost:8000/health` returns `{"status":"ok"}`.

---

### Task 1.3: Environment config files

**Files:**
- `backend/.env.example` — all backend env vars
- `frontend/.env.example` — `VITE_SUPABASE_URL`, `VITE_SUPABASE_ANON_KEY`, `VITE_API_URL`
- `.gitignore` — exclude `venv/`, `.env`, `node_modules/`, `dist/`

**Validation:** `.env` is in `.gitignore`, `.env.example` files exist.

---

## Section 2: Supabase Auth Integration

### Task 2.1: Database schema with RLS

**File:** `backend/supabase/migrations/001_create_threads.sql`

```sql
create table public.threads (
    id uuid default gen_random_uuid() primary key,
    user_id uuid references auth.users(id) on delete cascade not null,
    title text not null default 'New Chat',
    last_response_id text,  -- OpenAI response ID for continuing conversation
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null
);

alter table public.threads enable row level security;

-- RLS policies: users only see/create/update/delete their own threads
-- Index on user_id
-- Auto-update updated_at trigger
```

**Design note:** No local message storage in Module 1. OpenAI manages conversation history via `previous_response_id`. We store only thread metadata.

**Validation:** Run SQL in Supabase SQL Editor. Table appears in Table Editor. RLS policies are visible.

---

### Task 2.2: Frontend auth (Supabase JS)

**Files:**
- `frontend/src/lib/supabase.ts` — Supabase client singleton
- `frontend/src/contexts/AuthContext.tsx` — Auth provider (user, session, signUp, signIn, signOut)
- `frontend/src/pages/AuthPage.tsx` — Login/signup form with shadcn components
- `frontend/src/components/UserMenu.tsx` — Dropdown with email + logout

**Install:** `npm install @supabase/supabase-js`

**Validation:** Sign up → redirected to chat. Logout → back to auth page. Sign in → chat page. User visible in Supabase dashboard.

---

### Task 2.3: Backend auth middleware

**File:** `backend/app/auth.py` — `get_current_user` FastAPI dependency

Validates Supabase JWT from `Authorization: Bearer <token>` header via `supabase.auth.get_user(token)`. Returns 401 on failure.

**Validation:** Protected endpoint returns 401 without token, 200 with valid token.

---

## Section 3: Chat UI

### Task 3.1: App layout with thread sidebar

**Files:**
- `frontend/src/App.tsx` — AuthProvider + conditional render (AuthPage vs ChatPage)
- `frontend/src/pages/ChatPage.tsx` — Sidebar + main message area layout
- `frontend/src/components/ThreadSidebar.tsx` — Thread list + "New Chat" button
- `frontend/src/components/ThreadItem.tsx` — Single thread row
- `frontend/src/hooks/useThreads.ts` — Thread CRUD via backend API
- `frontend/src/lib/api.ts` — Authenticated fetch wrapper (attaches Supabase JWT)

**Layout:**
- Left sidebar (~280px, collapsible on mobile): "New Chat" button, scrollable thread list sorted by `updated_at` desc
- Main area: header (thread title + UserMenu), message area, input at bottom

**Validation:** After login, sidebar renders. "New Chat" creates a thread visible in sidebar and Supabase.

---

### Task 3.2: Message display and input

**Files:**
- `frontend/src/components/MessageList.tsx` — Scrollable message container
- `frontend/src/components/MessageBubble.tsx` — User vs assistant styling
- `frontend/src/components/ChatInput.tsx` — Textarea + send button, Enter to send
- `frontend/src/hooks/useChat.ts` — Message state + SSE streaming

**Note:** Messages live in React state only (not persisted locally). OpenAI remembers context via `previous_response_id`.

**Validation:** Type a message, press Enter. User bubble appears. Assistant response streams in. Follow-up is contextually coherent.

---

## Section 4: Backend Chat API

### Task 4.1: Thread CRUD endpoints

**Files:**
- `backend/app/routers/threads.py` — `GET/POST/PATCH/DELETE /api/threads`
- `backend/app/models/threads.py` — Pydantic models (ThreadCreate, ThreadUpdate, ThreadResponse)

**RLS approach:** Create per-request Supabase client using the user's JWT so RLS policies apply automatically.

**Validation:** CRUD operations work via curl. 401 without auth.

---

### Task 4.2: Chat SSE endpoint with OpenAI Responses API

**Files:**
- `backend/app/routers/chat.py` — `POST /api/chat` → SSE stream
- `backend/app/models/chat.py` — ChatRequest (thread_id, message)
- `backend/app/services/openai_service.py` — OpenAI Responses API wrapper + LangSmith wrapping

**Flow:**
1. Look up thread → get `last_response_id`
2. Call `client.responses.create(model, input, previous_response_id, stream=True)`
3. Yield SSE events: `delta` (text chunks) and `done` (response_id)
4. Update thread's `last_response_id`

**Key details:**
- `wrap_openai` from `langsmith` patches the OpenAI client (not LangChain)
- `sse-starlette` for SSE responses
- OpenAI events: `response.output_text.delta` → text deltas, `response.completed` → done

**Validation:** Send a message → SSE deltas stream back → follow-up is contextually aware → `last_response_id` updated in DB.

---

### Task 4.3: Frontend SSE consumption

Wire `useChat.ts` to consume `POST /api/chat` via `fetch` + `ReadableStream` (not `EventSource`, which only supports GET).

Parse SSE events from the stream, append deltas to assistant message in state.

**Validation:** Full UI flow — message sends, response streams in word-by-word, streaming indicator works.

---

### Task 4.4: Auto-generate thread titles

After the first message in a new thread (when `last_response_id` is null), call OpenAI to generate a 3-5 word title and update the thread.

**Validation:** New thread gets a descriptive title after first exchange.

---

## Section 5: LangSmith Observability

### Task 5.1: Verify LangSmith tracing

Already wired via `wrap_openai` in Task 4.2. Add `@traceable` decorators to `chat` endpoint and `generate_thread_title`.

**Env vars:** `LANGSMITH_TRACING=true`, `LANGSMITH_API_KEY`, `LANGSMITH_PROJECT`

**Validation:** Send a chat message → trace appears in LangSmith dashboard with OpenAI call details, token usage, and latency.

---

## Section 6: End-to-End Validation

### Task 6.1: Full flow smoke test

1. Open `localhost:5173`, sign up
2. Create a new thread, send a question
3. Response streams in, thread title auto-updates
4. Send a follow-up — contextually coherent
5. Create a second thread, switch between them
6. Sign out, sign back in — threads persist in sidebar
7. Check LangSmith dashboard — all interactions traced

### Task 6.2: Error handling

- No auth token → 401 → redirect to login
- Invalid OpenAI key → user-friendly error toast
- Empty message → send button disabled
- Network error during streaming → error shown, allow retry

---

## Execution Order

| # | Task | Can parallelize with |
|---|------|---------------------|
| 1 | 1.1 Frontend scaffolding | 1.2 |
| 2 | 1.2 Backend scaffolding | 1.1 |
| 3 | 1.3 Env config | — |
| 4 | 2.1 DB schema + RLS | — |
| 5 | 2.2 Frontend auth | 2.3 |
| 6 | 2.3 Backend auth middleware | 2.2 |
| 7 | 3.1 Chat layout + sidebar | — |
| 8 | 4.1 Thread API endpoints | — |
| 9 | 4.2 Chat SSE + OpenAI | — |
| 10 | 3.2 Message display + input | — |
| 11 | 4.3 Frontend SSE wiring | — |
| 12 | 4.4 Auto-generate titles | — |
| 13 | 5.1 LangSmith verification | — |
| 14 | 6.1 E2E smoke test | — |
| 15 | 6.2 Error handling | — |

## Key Architecture Decisions

1. **No local message storage** — OpenAI manages history via `previous_response_id`. Changes in Module 2.
2. **RLS via user JWT** — Backend creates per-request Supabase client with user's token. No manual `user_id` filtering.
3. **SSE via `sse-starlette`** — Simpler than WebSockets, unidirectional. WebSockets reserved for Supabase Realtime in Module 2.
4. **LangSmith via `wrap_openai`** — Not LangChain. Standalone `langsmith` SDK patches OpenAI client directly.
5. **Frontend SSE via `fetch` + `ReadableStream`** — `EventSource` only supports GET; our endpoint is POST.

## File Tree

```
backend/
  .env.example
  requirements.txt
  app/
    __init__.py
    main.py
    config.py
    auth.py
    models/
      __init__.py
      threads.py
      chat.py
    routers/
      __init__.py
      threads.py
      chat.py
    services/
      __init__.py
      openai_service.py
  supabase/
    migrations/
      001_create_threads.sql

frontend/
  .env.example
  src/
    App.tsx
    lib/
      supabase.ts
      api.ts
    contexts/
      AuthContext.tsx
    pages/
      AuthPage.tsx
      ChatPage.tsx
    components/
      UserMenu.tsx
      ThreadSidebar.tsx
      ThreadItem.tsx
      MessageList.tsx
      MessageBubble.tsx
      ChatInput.tsx
    hooks/
      useThreads.ts
      useChat.ts
```
